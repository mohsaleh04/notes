# حل تمرین 35 - بررسی ابهام گرامر

## صورت سوال:

گرامر زیر را در نظر بگیرید با توجه به رشته `aa+a*`. آیا گرامر مورد نظر مبهم است؟

```
S → SS+ | SS* | a
```

## تحلیل:

### بررسی ابهام گرامر:

گرامر داده شده:

- `S → SS+ | SS* | a`

برای رشته `aa+a*` می‌خواهیم بررسی کنیم که آیا بیش از یک درخت تجزیه (parse tree) وجود دارد یا نه.

### درخت تجزیه اول:

```
        S
       /|\
      S S *
     /|\ |
    S S + a
    | |
    a a
```

مراحل اشتقاق:

1. `S → SS*`
2. `S → SS+` (برای S اول)
3. `S → a` (برای S اول از SS+)
4. `S → a` (برای S دوم از SS+)
5. `S → a` (برای S دوم از SS*)

### درخت تجزیه دوم:

```
        S
       /|\
      S S +
      | |\
      a S S
        | |
        a *
```

Wait، این درست نیست. بیایید دوباره تحلیل کنیم:

### درخت تجزیه دوم (صحیح):

```
          S
         /|\
        S S +
        | |\  
        a S S
          | |
          a *
```

این هم درست نیست چون `S*` معنی ندارد.

### تحلیل صحیح:

برای رشته `aa+a*`، بیایید تمام حالات ممکن را بررسی کنیم:

**حالت 1:** `((aa+)a)*`

```
        S
       /|\
      S S *
     /|\ |
    S S + a
    | |
    a a
```

**حالت 2:** `(a(a+a))*`

```
        S
       /|\
      S S *
      | |\
      a S S
       /|\ |
      S S + a
      | |
      a a
```

**حالت 3:** `a((a+a)*)`

```
        S
       /|\
      S S +
      | |\
      a S S
        | |
        a *
```

این درست نیست چون `a*` یک تولید مستقل نیست.

### نتیجه‌گیری:

پس از بررسی دقیق‌تر، می‌توان دو درخت تجزیه متفاوت برای رشته `aa+a*` پیدا کرد:

1. **تفسیر اول:** `((aa+)a)*` - ابتدا `aa+` محاسبه می‌شود، سپس نتیجه با `a` ضرب می‌شود
2. **تفسیر دوم:** `(a(a+a))*` - ابتدا `a+a` محاسبه می‌شود، سپس `a` در نتیجه ضرب می‌شود

## پاسخ نهایی:

**بله، گرامر مبهم است** چون برای رشته `aa+a*` بیش از یک درخت تجزیه وجود دارد که منجر به تفاسیر مختلف می‌شود.

### دلیل ابهام:

- عدم وجود قوانین اولویت برای عملگرهای `+` و `*`
- عدم وجود قوانین انجمان‌پذیری (associativity)
- ساختار گرامر اجازه تفسیرهای مختلف را می‌دهد

------------------------------------------------------------------------

برای تشخیص اینکه یک گرامر مبهم است یا نه، چندین روش وجود دارد:

## 1. روش تعریف (Definition Method)

**گرامر مبهم است اگر:**

- حداقل یک رشته در زبان آن گرامر، بیش از یک درخت تجزیه (parse tree) داشته باشد
- یا به عبارت دیگر، بیش از یک leftmost derivation یا rightmost derivation داشته باشد

## 2. روش‌های عملی تشخیص:

### الف) جستجوی رشته‌های مشکوک

رشته‌هایی که احتمال ابهام دارند:

- رشته‌های حاوی عملگرهای متوالی: `a+b*c`، `a*b+c`
- رشته‌های با پرانتزهای مختلف: `((a))`
- رشته‌های با ساختارهای تو در تو

### ب) بررسی الگوهای رایج مبهم

**الگوهای معمول که باعث ابهام می‌شوند:**

1. **مسئله Dangling Else:**
    
    ```
    S → if E then S | if E then S else S | other
    ```
    
2. **عدم اولویت عملگرها:**
    
    ```
    E → E + E | E * E | a
    ```
    
3. **ساختار بازگشتی نامشخص:**
    
    ```
    S → SS | a
    ```
    

### ج) روش Derivation Trees

برای رشته مشکوک، سعی کنید:

1. درخت تجزیه بسازید
2. اگر بیش از یک درخت معتبر پیدا کردید → مبهم است
3. اگر فقط یک درخت پیدا کردید → احتمالاً مبهم نیست

## 3. مثال عملی:

**گرامر:** `E → E + E | E * E | a` **رشته:** `a + a * a`

**درخت 1:** `(a + a) * a`

```
    E
   /|\
  E * E
 /|\ /
E + E a
|   |
a   a
```

**درخت 2:** `a + (a * a)`

```
    E
   /|\
  E + E
  |  /|\
  a E * E
    |   |
    a   a
```

دو درخت متفاوت → **گرامر مبهم است**

## 4. نکات مهم:

### چه زمانی گرامر مبهم نیست؟

- وقتی اولویت عملگرها مشخص باشد
- وقتی associativity (انجمان‌پذیری) تعریف شده باشد
- وقتی ساختار گرامر منحصر به فرد باشد

### علائم هشدار:

- ⚠️ قوانین مشابه: `A → BC | BD`
- ⚠️ بازگشت چپ و راست همزمان: `A → Aa | aA`
- ⚠️ عدم اولویت: عملگرها در یک سطح
- ⚠️ ساختارهای اختیاری پیچیده

## 5. روش سیستماتیک:

1. **انتخاب رشته‌های تست**
2. **ساخت درخت تجزیه**
3. **جستجوی درخت‌های جایگزین**
4. **مقایسه نتایج**

اگر برای هر رشته فقط یک درخت تجزیه پیدا کردید، احتمالاً گرامر مبهم نیست (اما این تضمین قطعی نیست).

**نکته:** تشخیص قطعی عدم ابهام یک مسئله undecidable است، اما می‌توان با روش‌های عملی بالا در اکثر موارد تشخیص داد.




----------------------------------------------------------------------

بیا این دو مسئله Follow رو حل کنیم:

## محاسبه Follow(A)

برای محاسبه Follow(A) باید همه جاهایی که A در سمت راست قوانین ظاهر میشه رو بررسی کنیم:

**قانون S → AB:**

- A در ابتدای سمت راست قرار داره
- بعد از A، نماد B قرار داره
- پس First(B) باید به Follow(A) اضافه بشه
- First(B) = {c, ε, D}
- چون B میتونه ε تولید کنه، Follow(S) هم باید اضافه بشه
- Follow(S) = {$} (چون S نماد شروع است)

**بررسی First(B):**

- B → c: پس c ∈ First(B)
- B → ε: پس ε ∈ First(B)
- B → D: پس First(D) = {d} ∈ First(B)

**نتیجه:** Follow(A) = {c, d, $}

## محاسبه Follow(B)

برای محاسبه Follow(B) باید همه جاهایی که B در سمت راست قوانین ظاهر میشه رو بررسی کنیم:

**قانون A → AXb:**

- هیچ B وجود نداره

**قانون X → d|dB|eBE:**

- در X → dB: B در انتهای سمت راست قرار داره پس Follow(X) باید به Follow(B) اضافه بشه
- در X → eBE: بعد از B، نماد E قرار داره پس First(E) = {a, ε} باید به Follow(B) اضافه بشه چون E میتونه ε تولید کنه، Follow(X) هم اضافه میشه

**قانون S → AB:**

- B در انتهای سمت راست قرار داره
- پس Follow(S) = {$} باید به Follow(B) اضافه بشه

**محاسبه Follow(X):** X فقط در قانون A → AXb ظاهر میشه:

- بعد از X، نماد b قرار داره
- پس Follow(X) = {b}

**نتیجه:** Follow(B) = {a, b, $}

## خلاصه پاسخ:

- **Follow(A) = {c, d, $}**
- **Follow(B) = {a, b, $}**



---------------------------------------------------------------------

# محاسبه Follow() برای گرامر داده شده

## گرامر:

```
expr → term rest
rest → + expr | - expr | ε
term → id
```

## مرحله 1: محاسبه First() برای همه نمادها

### First() پایانه‌ها:

- `First(+) = {+}`
- `First(-) = {-}`
- `First(id) = {id}`
- `First(ε) = {ε}`

### First() غیرپایانه‌ها:

- `First(term) = {id}` (چون term → id)
- `First(expr) = First(term) = {id}` (چون expr → term rest)
- `First(rest) = {+, -, ε}` (چون rest → + expr | - expr | ε)

## مرحله 2: محاسبه Follow() برای غیرپایانه‌ها

### Follow(expr):

1. expr نماد شروع است، پس `$` را اضافه می‌کنیم: `Follow(expr) = {$}`
2. در قانون `rest → + expr` و `rest → - expr`، expr در انتهاست، پس:
    - `Follow(expr) = Follow(expr) ∪ Follow(rest)`

### Follow(rest):

1. در قانون `expr → term rest`، rest در انتهاست، پس:
    - `Follow(rest) = Follow(expr) = {$}`

### Follow(term):

1. در قانون `expr → term rest`، بعد از term قرار دارد rest، پس:
    - `Follow(term) = First(rest) - {ε} = {+, -}`
    - چون ε در First(rest) است، باید Follow(expr) را هم اضافه کنیم:
    - `Follow(term) = {+, -} ∪ Follow(expr) = {+, -, $}`

## نتیجه نهایی:

### Follow Sets:

- **Follow(expr) = {$}**
- **Follow(rest) = {$}**
- **Follow(term) = {+, -, $}**

## توضیح منطق:

1. **expr**: تنها زمانی که در انتهای ورودی یا بعد از + و - قرار می‌گیرد
2. **rest**: همیشه در انتهای expr قرار دارد، پس Follow آن همان Follow(expr) است
3. **term**: می‌تواند بعد از آن +، - یا انتهای ورودی بیاید